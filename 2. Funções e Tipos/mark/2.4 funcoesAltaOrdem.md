# Principais funções de alta ordem
Uma função de alta ordem é aquela que recebe uma função como argumento ou retorna uma função como resultado 
```haskell
twice :: (a → a) → a → a
twice f x = f (f x)
```

## `map`
Aplica uma função a cada elemento de uma lista
- tipo: `map :: (a → b) → [a] → [b]`
Exemplo: 
```haskell
map (+1) [1,3,5,7]
[2,4,6,8]
```
Também pode ser definida usando compreesão de lista:
```haskell
map f xs = [f x | x <- xs]
```

Ou ainda com recursividade:
```haskell
map f [] = []
map f (x:xs) = f x : map f xs
```

## `filter`
Separa os elementos de uma lista que satsfazem uma condição, basicamente filtra o os elementos 
- `filter :: (a -> Bool) -> [a] -> [a]`

```haskell
filter even [1...10]
>>>[2, 4, 6, 8, 10]
```

Definição por compreesão de lista:
```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter p xs = [x | x <- xs, p x]
```

Definção por recursividade:
```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
```

## `foldr`
Ela pega uma lista e combina seus elementos com um acumulador, começando pelo final da lista.
- Processa da esquerda para a direita 

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
```
- Primeiro argumento: uma função que recebe um elemento da lista (a) e um acumulador (b), e devolve um novo acumulador (b).
- Segundo argumento: o valor inicial do acumulador.
- Terceiro argumento: a lista a ser processada.
- Retorna: um único valor do tipo b.

Dado um função binária f e um valor inicial z 
```haskell
foldr f z [x1, x2, x3]
= x1 `f` (x2 `f` (x3 `f` z))
```

Exemplo:
```haskell
foldr (+) 0 [1,2,3]
```

```txt
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6 
```

Outro exemplo:
```haskell
map f xs = foldr (\x acc -> f x : acc) [] xs
```
- `map f xs` Aplica a função f a cada elemento de xs
- `\x acc -> f x : acc` A função lambda que:
    - `x` é elemtno atual da lista 
    - `acc` é o acumulador da lista que estamos construindo 
    - `f x : acc` aplica f em x e adiciona no começo do acumulador 
- `[]` valor inicial do acumulador
- `xs` é a lista inicial 
Passo a passo para `map (*2) [1,2,3])`:
```txt
foldr (\x acc -> (*2) x : acc) [] [1,2,3]
= (\x acc -> (*2) x : acc) 1 (foldr (\x acc -> (*2) x : acc) [] [2,3])
= (*2) 1 : (foldr ... [2,3])
= 2 : (foldr (\x acc -> (*2) x : acc) [] [2,3])
= 2 : ( (\x acc -> (*2) x : acc) 2 (foldr ... [3]) )
= 2 : ( 4 : (foldr ... [3]) )
= 2 : (4 : ( (\x acc -> (*2) x : acc) 3 [] ))
= 2 : (4 : (6 : []))
= [2,4,6]
```

| Função               | Descrição                                                      | Exemplo                          | Resultado                     |
|----------------------|---------------------------------------------------------------|----------------------------------|-------------------------------|
| `map f lista`        | Aplica a função `f` a todos os elementos da lista.            | `map (+1) [1,2,3]`              | `[2,3,4]`                     |
| `filter p lista`     | Filtra elementos que satisfazem o predicado `p`.              | `filter even [1,2,3,4]`         | `[2,4]`                       |
| `foldl op ini lista` | Reduz a lista da esquerda para a direita com `op` e valor inicial `ini`. | `foldl (+) 0 [1,2,3]` | `6` (0+1+2+3)                 |
| `foldr op ini lista` | Reduz a lista da direita para a esquerda com `op` e valor inicial `ini`. | `foldr (:) [] [1,2,3]` | `[1,2,3]` (concatenação)      |
| `zip xs ys`          | Junta duas listas em uma lista de pares.                      | `zip [1,2] ['a','b']`           | `[(1,'a'), (2,'b')]`          |
| `zipWith f xs ys`    | Aplica `f` aos pares correspondentes de `xs` e `ys`.          | `zipWith (+) [1,2] [3,4]`       | `[4,6]` (1+3, 2+4)            |
| `unzip lista_pares`  | Divide uma lista de pares em duas listas.                     | `unzip [(1,'a'), (2,'b')]`      | `([1,2], ['a','b'])`          |
